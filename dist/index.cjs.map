{"version":3,"sources":["../src/index.mts","../src/lib/auth.mts","../src/lib/utils.mts","../src/lib/gsc.mts","../src/lib/sitemap.mts"],"sourcesContent":["import { getAccessToken } from \"./lib/auth.mjs\";\nimport {\n  convertToSiteUrl,\n  getPublishMetadata,\n  requestIndexing,\n  getEmojiForStatus,\n  getPageIndexingStatus,\n} from \"./lib/gsc.mjs\";\nimport { getSitemapPages } from \"./lib/sitemap.mjs\";\nimport { batch } from \"./lib/utils.mjs\";\nimport { readFileSync, existsSync, mkdirSync, writeFileSync } from \"fs\";\n\nconst CACHE_TIMEOUT = 1000 * 60 * 60 * 24 * 14; // 14 days\nconst input = process.argv[2];\n\nexport async function processSite(input: string) {\n  if (!input) {\n    console.error(\n      \"‚ùå Please provide a domain or site URL as the first argument.\"\n    );\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  const accessToken = await getAccessToken();\n  const siteUrl = convertToSiteUrl(input);\n  console.log(`üîé Processing site: ${siteUrl}`);\n  const cachePath = `.cache/${siteUrl\n    .replace(\"http://\", \"http_\")\n    .replace(\"https://\", \"https_\")\n    .replace(\"/\", \"_\")}.json`;\n\n  if (!accessToken) {\n    console.error(\"‚ùå Failed to get access token.\");\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  const [sitemaps, pages] = await getSitemapPages(accessToken, siteUrl);\n\n  if (sitemaps.length === 0) {\n    console.error(\n      \"‚ùå No sitemaps found, add them to Google Search Console and try again.\"\n    );\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  console.log(`üëâ Found ${pages.length} URLs in ${sitemaps.length} sitemap`);\n\n  const statusPerUrl = existsSync(cachePath)\n    ? JSON.parse(readFileSync(cachePath, \"utf8\"))\n    : {};\n  const pagesPerStatus: { [s: string]: string[] } | ArrayLike<unknown> = {};\n\n  const indexableStatuses = [\n    \"Discovered - currently not indexed\",\n    \"Crawled - currently not indexed\",\n    \"URL is unknown to Google\",\n    \"Forbidden\",\n    \"Error\",\n  ];\n\n  const shouldRecheck = (\n    status: string,\n    lastCheckedAt: string | number | Date\n  ) => {\n    const shouldIndexIt = indexableStatuses.includes(status);\n    const isOld =\n      new Date(lastCheckedAt) < new Date(Date.now() - CACHE_TIMEOUT);\n    return shouldIndexIt || isOld;\n  };\n\n  await batch(\n    async (url: string) => {\n      let result = statusPerUrl[url];\n      if (!result || shouldRecheck(result.status, result.lastCheckedAt)) {\n        const status = await getPageIndexingStatus(accessToken, siteUrl, url);\n        result = { status, lastCheckedAt: new Date().toISOString() };\n        statusPerUrl[url] = result;\n      }\n      pagesPerStatus[result.status] = pagesPerStatus[result.status]\n        ? [...(pagesPerStatus[result.status] as string[]), url]\n        : [url];\n    },\n    pages,\n    50,\n    (batchIndex: number, batchCount: any) => {\n      console.log(`üì¶ Batch ${batchIndex + 1} of ${batchCount} complete`);\n    }\n  );\n\n  console.log(``);\n  console.log(`üëç Done, here's the status of all ${pages.length} pages:`);\n  mkdirSync(\".cache\", { recursive: true });\n  writeFileSync(cachePath, JSON.stringify(statusPerUrl, null, 2));\n\n  for (const [status, pages] of Object.entries(pagesPerStatus)) {\n    const pagesArray = pages as string[];\n    console.log(\n      `‚Ä¢ ${getEmojiForStatus(status)} ${status}: ${pagesArray.length} pages`\n    );\n  }\n  console.log(\"\");\n  const indexablePages = Object.entries(pagesPerStatus).flatMap(\n    ([status, pages]) => (indexableStatuses.includes(status) ? pages : [])\n  );\n\n  if (indexablePages.length === 0) {\n    console.log(\n      `‚ú® There are no pages that can be indexed. Everything is already indexed!`\n    );\n  } else {\n    console.log(`‚ú® Found ${indexablePages.length} pages that can be indexed.`);\n    indexablePages.forEach((url) => console.log(`‚Ä¢ ${url}`));\n  }\n  console.log(``);\n\n  for (const url of indexablePages) {\n    console.log(`üìÑ Processing url: ${url}`);\n    const status = await getPublishMetadata(accessToken, url);\n    if (status === 404) {\n      await requestIndexing(accessToken, url);\n      console.log(\n        \"üöÄ Indexing requested successfully. It may take a few days for Google to process it.\"\n      );\n    } else if (status < 400) {\n      console.log(\n        `üïõ Indexing already requested previously. It may take a few days for Google to process it.`\n      );\n    }\n    console.log(``);\n  }\n\n  console.log(`üëç All done!`);\n  console.log(`üíñ Brought to you by https://twitter.com/RoyalB88`);\n  console.log(``);\n}\n\nprocessSite(input).catch(console.error);\n","import { google } from \"googleapis\";\nimport { existsSync, readFileSync } from \"fs\";\n\nexport async function getAccessToken() {\n  if (!existsSync(\"./service_account.json\")) {\n    console.error(\n      \"‚ùå service_account.json not found, please follow the instructions in README.md\"\n    );\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  const key = JSON.parse(readFileSync(\"./service_account.json\", \"utf8\"));\n  const jwtClient = new google.auth.JWT(\n    key.client_email,\n    undefined,\n    key.private_key,\n    [\n      \"https://www.googleapis.com/auth/webmasters.readonly\",\n      \"https://www.googleapis.com/auth/indexing\",\n    ],\n    undefined\n  );\n\n  const tokens = await jwtClient.authorize();\n  return tokens.access_token;\n}\n","const createChunks = (arr: string[] | any[], size: number) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>\n    arr.slice(i * size, i * size + size)\n  );\n\ninterface BatchProcess {\n  (url: string): Promise<void>;\n}\n\nexport async function batch(\n  task: BatchProcess,\n  items: string[],\n  batchSize: number,\n  onBatchComplete: {\n    (batchIndex: number, batchCount: number): void;\n    (arg0: number, arg1: number): void;\n  }\n): Promise<void> {\n  const chunks = createChunks(items, batchSize);\n  for (let i = 0; i < chunks.length; i++) {\n    await Promise.all(chunks[i].map(task));\n    onBatchComplete(i, chunks.length);\n  }\n}\n\nexport async function fetchRetry(\n  url: string | URL | Request,\n  options: RequestInit | undefined,\n  retries = 5\n) {\n  try {\n    const response = await fetch(url, options);\n    if (response.status >= 500) {\n      const body = await response.text();\n      throw new Error(`Server error code ${response.status}\\n${body}`);\n    }\n    return response;\n  } catch (err) {\n    if (retries <= 0) {\n      throw err;\n    }\n    return fetchRetry(url, options, retries - 1);\n  }\n}\n","import { fetchRetry } from \"./utils.mjs\";\n\nexport function convertToSiteUrl(input: string): string {\n  if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n    return input.endsWith(\"/\") ? input : `${input}/`;\n  }\n  return `sc-domain:${input}`;\n}\n\nexport async function getPageIndexingStatus(\n  accessToken: string,\n  siteUrl: string,\n  inspectionUrl: string\n): Promise<string> {\n  try {\n    const response = await fetchRetry(\n      `https://searchconsole.googleapis.com/v1/urlInspection/index:inspect`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          inspectionUrl,\n          siteUrl,\n        }),\n      }\n    );\n\n    if (response.status === 403) {\n      console.error(\n        `üîê This service account doesn't have access to this site.`\n      );\n      console.error(await response.text());\n      return \"Forbidden\";\n    }\n\n    if (response.status >= 300) {\n      console.error(`‚ùå Failed to get indexing status.`);\n      console.error(`Response was: ${response.status}`);\n      console.error(await response.text());\n      return \"Error\";\n    }\n\n    const body = await response.json();\n    return body.inspectionResult.indexStatusResult.coverageState;\n  } catch (error) {\n    console.error(`‚ùå Failed to get indexing status.`);\n    console.error(`Error was: ${error}`);\n    throw error;\n  }\n}\n\nexport function getEmojiForStatus(status: string) {\n  switch (status) {\n    case \"Submitted and indexed\":\n      return \"‚úÖ\";\n    case \"Duplicate without user-selected canonical\":\n      return \"üòµ\";\n    case \"Crawled - currently not indexed\":\n    case \"Discovered - currently not indexed\":\n      return \"üëÄ\";\n    case \"Page with redirect\":\n      return \"üîÄ\";\n    case \"URL is unknown to Google\":\n      return \"‚ùì\";\n    default:\n      return \"‚ùå\";\n  }\n}\n\nexport async function getPublishMetadata(\n  accessToken: string,\n  url: string\n): Promise<number> {\n  const response = await fetchRetry(\n    `https://indexing.googleapis.com/v3/urlNotifications/metadata?url=${encodeURIComponent(\n      url\n    )}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  if (response.status === 403) {\n    console.error(`üîê This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  if (response.status >= 500) {\n    console.error(`‚ùå Failed to get publish metadata.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  return response.status;\n}\n\nexport async function requestIndexing(\n  accessToken: string,\n  url: string\n): Promise<void> {\n  const response = await fetchRetry(\n    \"https://indexing.googleapis.com/v3/urlNotifications:publish\",\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        url: url,\n        type: \"URL_UPDATED\",\n      }),\n    }\n  );\n\n  if (response.status === 403) {\n    console.error(`üîê This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n  }\n\n  if (response.status >= 300) {\n    console.error(`‚ùå Failed to request indexing.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n}\n","import Sitemapper from \"sitemapper\";\nimport { fetchRetry } from \"./utils.mjs\";\n\nasync function getSitemapsList(\n  accessToken: string,\n  siteUrl: string\n): Promise<string[]> {\n  const url = `https://www.googleapis.com/webmasters/v3/sites/${encodeURIComponent(\n    siteUrl\n  )}/sitemaps`;\n\n  const response = await fetchRetry(url, {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (response.status === 403) {\n    console.error(`üîê This service account doesn't have access to this site.`);\n    return [];\n  }\n\n  if (response.status >= 300) {\n    console.error(`‚ùå Failed to get list of sitemaps.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n    return [];\n  }\n\n  const body = await response.json();\n  return body.sitemap.map((x: { path: string }) => x.path);\n}\n\nexport async function getSitemapPages(\n  accessToken: string,\n  siteUrl: string\n): Promise<[string[], string[]]> {\n  try {\n    const sitemaps = await getSitemapsList(accessToken, siteUrl);\n\n    let pages: Iterable<any> | null | undefined = [];\n    for (const url of sitemaps) {\n      // @ts-ignore\n      const Google = new Sitemapper({ url });\n\n      const { sites } = await Google.fetch();\n      pages = [...pages, ...sites];\n    }\n\n    return [sitemaps, [...new Set(pages)]];\n  } catch (error) {\n    console.error(`‚ùå Failed to get sitemap pages.`);\n    console.error(`Error was: ${error}`);\n    return [[], []];\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,wBAAuB;AACvB,gBAAyC;AAEzC,eAAsB,iBAAiB;AACrC,MAAI,KAAC,sBAAW,wBAAwB,GAAG;AACzC,YAAQ;AAAA,MACN;AAAA,IACF;AACA,YAAQ,MAAM,EAAE;AAChB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,MAAM,KAAK,UAAM,wBAAa,0BAA0B,MAAM,CAAC;AACrE,QAAM,YAAY,IAAI,yBAAO,KAAK;AAAA,IAChC,IAAI;AAAA,IACJ;AAAA,IACA,IAAI;AAAA,IACJ;AAAA,MACE;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AAEA,QAAM,SAAS,MAAM,UAAU,UAAU;AACzC,SAAO,OAAO;AAChB;;;AC1BA,IAAM,eAAe,CAAC,KAAuB,SAC3C,MAAM;AAAA,EAAK,EAAE,QAAQ,KAAK,KAAK,IAAI,SAAS,IAAI,EAAE;AAAA,EAAG,CAAC,GAAG,MACvD,IAAI,MAAM,IAAI,MAAM,IAAI,OAAO,IAAI;AACrC;AAMF,eAAsB,MACpB,MACA,OACA,WACA,iBAIe;AACf,QAAM,SAAS,aAAa,OAAO,SAAS;AAC5C,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,QAAQ,IAAI,OAAO,CAAC,EAAE,IAAI,IAAI,CAAC;AACrC,oBAAgB,GAAG,OAAO,MAAM;AAAA,EAClC;AACF;AAEA,eAAsB,WACpB,KACA,SACA,UAAU,GACV;AACA,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,KAAK,OAAO;AACzC,QAAI,SAAS,UAAU,KAAK;AAC1B,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAM,IAAI,MAAM,qBAAqB,SAAS,MAAM;AAAA,EAAK,IAAI,EAAE;AAAA,IACjE;AACA,WAAO;AAAA,EACT,SAAS,KAAK;AACZ,QAAI,WAAW,GAAG;AAChB,YAAM;AAAA,IACR;AACA,WAAO,WAAW,KAAK,SAAS,UAAU,CAAC;AAAA,EAC7C;AACF;;;ACzCO,SAAS,iBAAiBA,QAAuB;AACtD,MAAIA,OAAM,WAAW,SAAS,KAAKA,OAAM,WAAW,UAAU,GAAG;AAC/D,WAAOA,OAAM,SAAS,GAAG,IAAIA,SAAQ,GAAGA,MAAK;AAAA,EAC/C;AACA,SAAO,aAAaA,MAAK;AAC3B;AAEA,eAAsB,sBACpB,aACA,SACA,eACiB;AACjB,MAAI;AACF,UAAM,WAAW,MAAM;AAAA,MACrB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,eAAe,UAAU,WAAW;AAAA,QACtC;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,SAAS,WAAW,KAAK;AAC3B,cAAQ;AAAA,QACN;AAAA,MACF;AACA,cAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AACnC,aAAO;AAAA,IACT;AAEA,QAAI,SAAS,UAAU,KAAK;AAC1B,cAAQ,MAAM,uCAAkC;AAChD,cAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAChD,cAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AACnC,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC,WAAO,KAAK,iBAAiB,kBAAkB;AAAA,EACjD,SAAS,OAAO;AACd,YAAQ,MAAM,uCAAkC;AAChD,YAAQ,MAAM,cAAc,KAAK,EAAE;AACnC,UAAM;AAAA,EACR;AACF;AAEO,SAAS,kBAAkB,QAAgB;AAChD,UAAQ,QAAQ;AAAA,IACd,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEA,eAAsB,mBACpB,aACA,KACiB;AACjB,QAAM,WAAW,MAAM;AAAA,IACrB,oEAAoE;AAAA,MAClE;AAAA,IACF,CAAC;AAAA,IACD;AAAA,MACE,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,eAAe,UAAU,WAAW;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS,WAAW,KAAK;AAC3B,YAAQ,MAAM,kEAA2D;AACzE,YAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAChD,YAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AAAA,EACrC;AAEA,MAAI,SAAS,UAAU,KAAK;AAC1B,YAAQ,MAAM,wCAAmC;AACjD,YAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAChD,YAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AAAA,EACrC;AAEA,SAAO,SAAS;AAClB;AAEA,eAAsB,gBACpB,aACA,KACe;AACf,QAAM,WAAW,MAAM;AAAA,IACrB;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,eAAe,UAAU,WAAW;AAAA,MACtC;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACnB;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI,SAAS,WAAW,KAAK;AAC3B,YAAQ,MAAM,kEAA2D;AACzE,YAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAAA,EAClD;AAEA,MAAI,SAAS,UAAU,KAAK;AAC1B,YAAQ,MAAM,oCAA+B;AAC7C,YAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAChD,YAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AAAA,EACrC;AACF;;;ACrIA,wBAAuB;AAGvB,eAAe,gBACb,aACA,SACmB;AACnB,QAAM,MAAM,kDAAkD;AAAA,IAC5D;AAAA,EACF,CAAC;AAED,QAAM,WAAW,MAAM,WAAW,KAAK;AAAA,IACrC,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,eAAe,UAAU,WAAW;AAAA,IACtC;AAAA,EACF,CAAC;AAED,MAAI,SAAS,WAAW,KAAK;AAC3B,YAAQ,MAAM,kEAA2D;AACzE,WAAO,CAAC;AAAA,EACV;AAEA,MAAI,SAAS,UAAU,KAAK;AAC1B,YAAQ,MAAM,wCAAmC;AACjD,YAAQ,MAAM,iBAAiB,SAAS,MAAM,EAAE;AAChD,YAAQ,MAAM,MAAM,SAAS,KAAK,CAAC;AACnC,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,OAAO,MAAM,SAAS,KAAK;AACjC,SAAO,KAAK,QAAQ,IAAI,CAAC,MAAwB,EAAE,IAAI;AACzD;AAEA,eAAsB,gBACpB,aACA,SAC+B;AAC/B,MAAI;AACF,UAAM,WAAW,MAAM,gBAAgB,aAAa,OAAO;AAE3D,QAAI,QAA0C,CAAC;AAC/C,eAAW,OAAO,UAAU;AAE1B,YAAM,SAAS,IAAI,kBAAAC,QAAW,EAAE,IAAI,CAAC;AAErC,YAAM,EAAE,MAAM,IAAI,MAAM,OAAO,MAAM;AACrC,cAAQ,CAAC,GAAG,OAAO,GAAG,KAAK;AAAA,IAC7B;AAEA,WAAO,CAAC,UAAU,CAAC,GAAG,IAAI,IAAI,KAAK,CAAC,CAAC;AAAA,EACvC,SAAS,OAAO;AACd,YAAQ,MAAM,qCAAgC;AAC9C,YAAQ,MAAM,cAAc,KAAK,EAAE;AACnC,WAAO,CAAC,CAAC,GAAG,CAAC,CAAC;AAAA,EAChB;AACF;;;AJ9CA,IAAAC,aAAmE;AAEnE,IAAM,gBAAgB,MAAO,KAAK,KAAK,KAAK;AAC5C,IAAM,QAAQ,QAAQ,KAAK,CAAC;AAE5B,eAAsB,YAAYC,QAAe;AAC/C,MAAI,CAACA,QAAO;AACV,YAAQ;AAAA,MACN;AAAA,IACF;AACA,YAAQ,MAAM,EAAE;AAChB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,cAAc,MAAM,eAAe;AACzC,QAAM,UAAU,iBAAiBA,MAAK;AACtC,UAAQ,IAAI,8BAAuB,OAAO,EAAE;AAC5C,QAAM,YAAY,UAAU,QACzB,QAAQ,WAAW,OAAO,EAC1B,QAAQ,YAAY,QAAQ,EAC5B,QAAQ,KAAK,GAAG,CAAC;AAEpB,MAAI,CAAC,aAAa;AAChB,YAAQ,MAAM,oCAA+B;AAC7C,YAAQ,MAAM,EAAE;AAChB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,QAAM,CAAC,UAAU,KAAK,IAAI,MAAM,gBAAgB,aAAa,OAAO;AAEpE,MAAI,SAAS,WAAW,GAAG;AACzB,YAAQ;AAAA,MACN;AAAA,IACF;AACA,YAAQ,MAAM,EAAE;AAChB,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,UAAQ,IAAI,mBAAY,MAAM,MAAM,YAAY,SAAS,MAAM,UAAU;AAEzE,QAAM,mBAAe,uBAAW,SAAS,IACrC,KAAK,UAAM,yBAAa,WAAW,MAAM,CAAC,IAC1C,CAAC;AACL,QAAM,iBAAiE,CAAC;AAExE,QAAM,oBAAoB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,gBAAgB,CACpB,QACA,kBACG;AACH,UAAM,gBAAgB,kBAAkB,SAAS,MAAM;AACvD,UAAM,QACJ,IAAI,KAAK,aAAa,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,aAAa;AAC/D,WAAO,iBAAiB;AAAA,EAC1B;AAEA,QAAM;AAAA,IACJ,OAAO,QAAgB;AACrB,UAAI,SAAS,aAAa,GAAG;AAC7B,UAAI,CAAC,UAAU,cAAc,OAAO,QAAQ,OAAO,aAAa,GAAG;AACjE,cAAM,SAAS,MAAM,sBAAsB,aAAa,SAAS,GAAG;AACpE,iBAAS,EAAE,QAAQ,gBAAe,oBAAI,KAAK,GAAE,YAAY,EAAE;AAC3D,qBAAa,GAAG,IAAI;AAAA,MACtB;AACA,qBAAe,OAAO,MAAM,IAAI,eAAe,OAAO,MAAM,IACxD,CAAC,GAAI,eAAe,OAAO,MAAM,GAAgB,GAAG,IACpD,CAAC,GAAG;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA,CAAC,YAAoB,eAAoB;AACvC,cAAQ,IAAI,mBAAY,aAAa,CAAC,OAAO,UAAU,WAAW;AAAA,IACpE;AAAA,EACF;AAEA,UAAQ,IAAI,EAAE;AACd,UAAQ,IAAI,4CAAqC,MAAM,MAAM,SAAS;AACtE,4BAAU,UAAU,EAAE,WAAW,KAAK,CAAC;AACvC,gCAAc,WAAW,KAAK,UAAU,cAAc,MAAM,CAAC,CAAC;AAE9D,aAAW,CAAC,QAAQC,MAAK,KAAK,OAAO,QAAQ,cAAc,GAAG;AAC5D,UAAM,aAAaA;AACnB,YAAQ;AAAA,MACN,UAAK,kBAAkB,MAAM,CAAC,IAAI,MAAM,KAAK,WAAW,MAAM;AAAA,IAChE;AAAA,EACF;AACA,UAAQ,IAAI,EAAE;AACd,QAAM,iBAAiB,OAAO,QAAQ,cAAc,EAAE;AAAA,IACpD,CAAC,CAAC,QAAQA,MAAK,MAAO,kBAAkB,SAAS,MAAM,IAAIA,SAAQ,CAAC;AAAA,EACtE;AAEA,MAAI,eAAe,WAAW,GAAG;AAC/B,YAAQ;AAAA,MACN;AAAA,IACF;AAAA,EACF,OAAO;AACL,YAAQ,IAAI,gBAAW,eAAe,MAAM,6BAA6B;AACzE,mBAAe,QAAQ,CAAC,QAAQ,QAAQ,IAAI,UAAK,GAAG,EAAE,CAAC;AAAA,EACzD;AACA,UAAQ,IAAI,EAAE;AAEd,aAAW,OAAO,gBAAgB;AAChC,YAAQ,IAAI,6BAAsB,GAAG,EAAE;AACvC,UAAM,SAAS,MAAM,mBAAmB,aAAa,GAAG;AACxD,QAAI,WAAW,KAAK;AAClB,YAAM,gBAAgB,aAAa,GAAG;AACtC,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF,WAAW,SAAS,KAAK;AACvB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AACA,YAAQ,IAAI,EAAE;AAAA,EAChB;AAEA,UAAQ,IAAI,qBAAc;AAC1B,UAAQ,IAAI,0DAAmD;AAC/D,UAAQ,IAAI,EAAE;AAChB;AAEA,YAAY,KAAK,EAAE,MAAM,QAAQ,KAAK;","names":["input","Sitemapper","import_fs","input","pages"]}